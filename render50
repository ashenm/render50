#!/usr/bin/env python

from __future__ import print_function
import argparse
import os
import signal
import sys
import textwrap

from backports.shutil_which import which
from backports.shutil_get_terminal_size import get_terminal_size
from pygments import highlight
from pygments.lexers import PythonLexer
from pygments.formatters import HtmlFormatter
import termcolor


class Error(Exception):
    """Exception raised for errors."""
    pass


def main():
    """
    """

    # Exit on ctrl-c
    def handler(signum, frame):
        print("")
        sys.exit(1)
    signal.signal(signal.SIGINT, handler) 
   
    # Parse command-line arguments
    parser = argparse.ArgumentParser(description="A command-line tool that "
                                                 "renders source code as a PDF.")
    parser.add_argument("-r", "--recursive",
            action="store_true",
            help="recurse into directories")
    parser.add_argument("output", help="file to output")
    parser.add_argument("input", help="input to render", nargs="+")
    parser.add_argument("-i", "--include", action="append", help="pattern to include", nargs=1)
    parser.add_argument("-x", "--exclude", action="append", help="pattern to exclude", nargs=1)
    args = parser.parse_args(sys.argv[1:])
    
    # Require wkhtmltopdf
    if not which("wkhtmltopdf"):
        raise Error("You don't have wkhtmltopdf installed. Install wkhtmltopdf, then re-run render50!.")

    # Ensure output ends in .pdf
    output = args.output
    if not output.lower().endswith(".pdf"):
        output += ".pdf"

    # Create parent directory as needed
    output = os.path.realpath(output)
    dirname = os.path.dirname(output)
    print(dirname)
    if not os.path.isdir(dirname):
        while True:
            s = input("Create {}? ".format(dirname))
            if s.lower() in ["n", "no"]:
                raise Error()
            elif s.lower() in ["y", "yes"]:
                try:
                    os.makedirs(dirname)
                except Exception:
                    e = Error("Could not create {}.".format(dirname))
                    e.__cause__ = None
                    raise e

    # Prompt whether to overwrite file as needed
    if os.path.exists(output):
        while True:
            s = input("Overwrite {}? ".format(output))
            if s.lower() in ["n", "no"]:
                raise Error()

    # Check for includes
    # TODO

    # Check for excludes
    # TODO

    # Check for inputs
    inputs = args.input
    if "--" in args.input:
        inputs += sys.stdin.readlines()

    # Glob patterns lest shell (e.g., Windows) not have done so
    # TODO

    # Queue files for rendering
    # TODO
    queue = []
    for input in inputs:
        pass

    # Render files
    # TODO
    for file in queue:
        pass

    print(args)


def cprint(text="", color=None, on_color=None, attrs=None, **kwargs):
    """Colorizes text (and wraps to terminal's width)."""

    # Assume 80 in case not running in a terminal
    columns, _ = get_terminal_size((80, 0))

    # Only python3 supports "flush" keyword argument
    if sys.version_info < (3, 0) and "flush" in kwargs:
        del kwargs["flush"]

    # Print text
    termcolor.cprint(textwrap.fill(text, columns, drop_whitespace=False),
                     color=color, on_color=on_color, attrs=attrs, **kwargs)


def excepthook(type, value, tb):
    """Report an exception."""
    excepthook.ignore = False
    if type is Error and str(value):
        cprint(str(value), "yellow")
    cprint("Rendering cancelled.", "red")
sys.excepthook = excepthook


if __name__ == "__main__":
    main()
